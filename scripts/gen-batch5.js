import { writeFileSync, mkdirSync } from 'node:fs';

const SKILLS = [
  { slug:'home-assistant-api', displayName:'Home Assistant API', category:'IoT', icon:'home', description:'Control smart home devices and automations via Home Assistant API.', tags:['home-assistant','iot','smart-home','automation'], actions:[
    { name:'get_states', method:'GET', path:'/api/states', params:[], response:{value:[{entity_id:'light.living_room',state:'on'}]} },
    { name:'get_entity', method:'GET', pathTemplate:'/api/states/{entityId}', params:[{n:'entityId',req:true,t:'string'}], response:{entity_id:'light.living_room',state:'on',attributes:{brightness:255}} },
    { name:'call_service', method:'POST', pathTemplate:'/api/services/{domain}/{service}', params:[{n:'domain',req:true,t:'string'},{n:'service',req:true,t:'string'},{n:'entityId',req:false,t:'string'}], response:{} },
    { name:'get_history', method:'GET', pathTemplate:'/api/history/period?filter_entity_id={entityId}', params:[{n:'entityId',req:true,t:'string'},{n:'startTime',req:false,t:'string'}], response:[[{state:'on',last_changed:'2024-01-01T00:00:00Z'}]] },
  ]},
  { slug:'plex-api', displayName:'Plex Media Server API', category:'Media', icon:'film', description:'Browse and manage media libraries on Plex Media Server.', tags:['plex','media','streaming','library'], actions:[
    { name:'get_libraries', method:'GET', path:'/library/sections', params:[], response:{MediaContainer:{Directory:[{key:'1',title:'Movies',type:'movie'}]}} },
    { name:'search_media', method:'GET', pathTemplate:'/search?query={query}&type={type}', params:[{n:'query',req:true,t:'string'},{n:'type',req:false,t:'string'}], response:{MediaContainer:{Metadata:[{title:'Inception',year:2010}]}} },
    { name:'get_recently_added', method:'GET', pathTemplate:'/library/recentlyAdded?X-Plex-Container-Start=0&X-Plex-Container-Size={count}', params:[{n:'count',req:false,t:'number',def:10}], response:{MediaContainer:{Metadata:[{title:'New Movie',addedAt:1700000000}]}} },
    { name:'get_sessions', method:'GET', path:'/status/sessions', params:[], response:{MediaContainer:{Metadata:[{title:'Playing Movie',User:{title:'John'}}]}} },
  ]},
  { slug:'transmission-rpc', displayName:'Transmission RPC API', category:'Media', icon:'download', description:'Manage torrent downloads via Transmission RPC interface.', tags:['transmission','torrent','download','rpc'], actions:[
    { name:'list_torrents', method:'POST', path:'/transmission/rpc', params:[], response:{arguments:{torrents:[{id:1,name:'ubuntu.iso',status:6,percentDone:1}]}} },
    { name:'add_torrent', method:'POST', path:'/transmission/rpc', params:[{n:'url',req:true,t:'string'}], response:{arguments:{'torrent-added':{id:2,name:'file.iso'}}} },
    { name:'remove_torrent', method:'POST', path:'/transmission/rpc', params:[{n:'torrentId',req:true,t:'string'},{n:'deleteData',req:false,t:'boolean',def:false}], response:{result:'success'} },
    { name:'get_session', method:'POST', path:'/transmission/rpc', params:[], response:{arguments:{'download-dir':'/downloads','speed-limit-down':1000}} },
  ]},
  { slug:'calibre-api', displayName:'Calibre Content Server API', category:'Media', icon:'book', description:'Browse and manage ebook libraries via Calibre Content Server.', tags:['calibre','ebook','library','reading'], actions:[
    { name:'list_books', method:'GET', pathTemplate:'/ajax/search?query={query}&num={num}', params:[{n:'query',req:false,t:'string'},{n:'num',req:false,t:'number',def:20}], response:{total_num:100,book_ids:[1,2,3]} },
    { name:'get_book', method:'GET', pathTemplate:'/ajax/book/{bookId}', params:[{n:'bookId',req:true,t:'string'}], response:{title:'Dune',authors:['Frank Herbert'],formats:['epub','pdf']} },
    { name:'get_categories', method:'GET', path:'/ajax/categories', params:[], response:{category_map:{tags:{},authors:{}}} },
    { name:'search_books', method:'GET', pathTemplate:'/ajax/search?query={query}', params:[{n:'query',req:true,t:'string'}], response:{total_num:5,book_ids:[1,2]} },
  ]},
  { slug:'frigate-nvr-api', displayName:'Frigate NVR API', category:'IoT', icon:'camera', description:'Monitor cameras, view events, and manage recordings via Frigate NVR.', tags:['frigate','nvr','camera','security'], actions:[
    { name:'get_events', method:'GET', pathTemplate:'/api/events?limit={limit}&label={label}', params:[{n:'limit',req:false,t:'number',def:20},{n:'label',req:false,t:'string'}], response:[{id:'ev1',camera:'front_door',label:'person',start_time:1700000000}] },
    { name:'get_config', method:'GET', path:'/api/config', params:[], response:{cameras:{front_door:{enabled:true}},detectors:{coral:{type:'edgetpu'}}} },
    { name:'get_stats', method:'GET', path:'/api/stats', params:[], response:{cameras:{front_door:{fps:15,detection_fps:5}},cpu_usages:{}} },
    { name:'get_recordings', method:'GET', pathTemplate:'/api/{camera}/recordings/summary', params:[{n:'camera',req:true,t:'string'}], response:[{day:'2024-01-01',hours:[{hour:0,duration:3600}]}] },
  ]},
  { slug:'video-editor-ffmpeg', displayName:'Video Editor (FFmpeg)', category:'Media', icon:'scissors', description:'Process and transform video/audio files using FFmpeg commands.', tags:['ffmpeg','video','audio','media'], actions:[
    { name:'get_info', method:'GET', pathTemplate:'/probe?file={filePath}', params:[{n:'filePath',req:true,t:'string'}], response:{format:{duration:'120.5',size:'50000000'},streams:[{codec_type:'video',width:1920,height:1080}]} },
    { name:'convert', method:'POST', path:'/convert', params:[{n:'input',req:true,t:'string'},{n:'output',req:true,t:'string'},{n:'format',req:false,t:'string'}], response:{status:'completed',outputPath:'/output/video.mp4'} },
    { name:'extract_audio', method:'POST', path:'/extract-audio', params:[{n:'input',req:true,t:'string'},{n:'output',req:true,t:'string'}], response:{status:'completed',outputPath:'/output/audio.mp3'} },
    { name:'thumbnail', method:'POST', path:'/thumbnail', params:[{n:'input',req:true,t:'string'},{n:'timestamp',req:false,t:'string',def:'00:00:01'}], response:{status:'completed',outputPath:'/output/thumb.jpg'} },
  ]},
  { slug:'color-palette-extractor', displayName:'Color Palette Extractor', category:'Media', icon:'palette', description:'Extract dominant colors and generate palettes from images.', tags:['color','palette','image','design'], actions:[
    { name:'extract_palette', method:'POST', path:'/extract', params:[{n:'imageUrl',req:true,t:'string'},{n:'count',req:false,t:'number',def:5}], response:{colors:['#FF5733','#33FF57','#3357FF'],palette_name:'Vibrant'} },
    { name:'get_complementary', method:'POST', path:'/complementary', params:[{n:'color',req:true,t:'string'}], response:{input:'#FF5733',complementary:'#33CCFF',triadic:['#57FF33','#3357FF']} },
    { name:'analyze_image', method:'POST', path:'/analyze', params:[{n:'imageUrl',req:true,t:'string'}], response:{dominant:'#FF5733',brightness:0.65,contrast:0.8,warmth:'warm'} },
    { name:'generate_palette', method:'POST', path:'/generate', params:[{n:'baseColor',req:true,t:'string'},{n:'scheme',req:false,t:'string',def:'analogous'}], response:{colors:['#FF5733','#FF8D33','#FFC133'],scheme:'analogous'} },
  ]},
  { slug:'music-generator', displayName:'Music Generator', category:'Media', icon:'music', description:'Generate music, melodies, and audio compositions via AI music APIs.', tags:['music','audio','generation','ai'], actions:[
    { name:'generate_track', method:'POST', path:'/generate', params:[{n:'prompt',req:true,t:'string'},{n:'duration',req:false,t:'number',def:30},{n:'genre',req:false,t:'string'}], response:{trackId:'trk1',url:'https://example.com/track.mp3',duration:30} },
    { name:'get_track', method:'GET', pathTemplate:'/tracks/{trackId}', params:[{n:'trackId',req:true,t:'string'}], response:{trackId:'trk1',status:'completed',url:'https://example.com/track.mp3'} },
    { name:'list_tracks', method:'GET', pathTemplate:'/tracks?limit={limit}', params:[{n:'limit',req:false,t:'number',def:10}], response:{tracks:[{trackId:'trk1',prompt:'chill lo-fi'}]} },
    { name:'get_genres', method:'GET', path:'/genres', params:[], response:{genres:['lo-fi','jazz','electronic','classical']} },
  ]},
];

// --- Templates (same proven pattern as Batch 4) ---
function genHandler(s) {
  const actionNames = s.actions.map(a => `'${a.name}'`).join(', ');
  const validationCases = s.actions.map(a => {
    const rp = a.params.filter(p => p.req);
    if (!rp.length) return `    case '${a.name}': return { valid: true };`;
    const checks = rp.map(p => `      const v_${p.n} = validateNonEmptyString(params.${p.n}, '${p.n}');\n      if (!v_${p.n}.valid) return { valid: false, error: v_${p.n}.error };`).join('\n');
    return `    case '${a.name}': {\n${checks}\n      return { valid: true };\n    }`;
  }).join('\n');

  const handlers = s.actions.map(a => {
    const fn = 'handle' + a.name.split('_').map(w => w[0].toUpperCase() + w.slice(1)).join('');
    const rp = a.params.filter(p => p.req);
    const valBlock = rp.map(p => `  const v_${p.n} = validateNonEmptyString(params.${p.n}, '${p.n}');\n  if (!v_${p.n}.valid) return { result: \`Error: \${v_${p.n}.error}\`, metadata: { success: false, action: '${a.name}', error: 'INVALID_INPUT', timestamp: new Date().toISOString() } };`).join('\n');
    let pathExpr;
    if (a.pathTemplate) { let t = a.pathTemplate; a.params.forEach(p => { if (t.includes(`{${p.n}}`)) t = t.replace(`{${p.n}}`, p.req ? `\${encodeURIComponent(v_${p.n}.value)}` : `\${encodeURIComponent(String(params.${p.n} ?? '${p.def??''}'))}`); }); pathExpr = `\`${t}\``; } else { pathExpr = `'${a.path}'`; }
    return `async function ${fn}(params, context) {\n${valBlock}\n  const resolved = getClient(context);\n  if (!resolved) return providerNotConfiguredError();\n  const timeoutMs = resolveTimeout(context);\n  try {\n    const data = await requestWithTimeout(resolved.client, '${a.method}', ${pathExpr}, {}, timeoutMs);\n    return { result: redactSensitive(JSON.stringify(data, null, 2)), metadata: { success: true, action: '${a.name}', timestamp: new Date().toISOString() } };\n  } catch (err) {\n    return { result: redactSensitive(\`Error: \${err.message}\`), metadata: { success: false, action: '${a.name}', error: err.code || 'UPSTREAM_ERROR', timestamp: new Date().toISOString() } };\n  }\n}`;
  }).join('\n\n');

  const switchCases = s.actions.map(a => { const fn = 'handle' + a.name.split('_').map(w => w[0].toUpperCase() + w.slice(1)).join(''); return `      case '${a.name}': return await ${fn}(params, context);`; }).join('\n');

  return `/**\n * ${s.displayName} Skill Handler (Layer 1)\n * ${s.description}\n */\n\nconst VALID_ACTIONS = [${actionNames}];\nconst DEFAULT_TIMEOUT_MS = 30000;\nconst MAX_TIMEOUT_MS = 120000;\n\nfunction getClient(context) {\n  if (context?.providerClient) return { client: context.providerClient, type: 'provider' };\n  if (context?.gatewayClient) return { client: context.gatewayClient, type: 'gateway' };\n  return null;\n}\n\nfunction providerNotConfiguredError() {\n  return { result: 'Error: Provider client required for ${s.displayName} access.', metadata: { success: false, error: { code: 'PROVIDER_NOT_CONFIGURED', message: 'Provider client required.', retriable: false } } };\n}\n\nfunction resolveTimeout(context) {\n  const c = context?.config?.timeoutMs;\n  if (typeof c === 'number' && c > 0) return Math.min(c, MAX_TIMEOUT_MS);\n  return DEFAULT_TIMEOUT_MS;\n}\n\nasync function requestWithTimeout(client, method, path, opts, timeoutMs) {\n  const controller = new AbortController();\n  const timer = setTimeout(() => controller.abort(), timeoutMs);\n  try { const r = await client.request(method, path, null, { ...opts, signal: controller.signal }); clearTimeout(timer); return r; }\n  catch (err) { clearTimeout(timer); if (err.name === 'AbortError') throw { code: 'TIMEOUT', message: \`Request timed out after \${timeoutMs}ms.\` }; throw { code: 'UPSTREAM_ERROR', message: err.message || 'Unknown upstream error' }; }\n}\n\nconst SENSITIVE_PATTERNS = [/(?:api[_-]?key|token|secret|password|authorization|bearer)\\s*[:=]\\s*\\S+/gi];\nfunction redactSensitive(text) { if (typeof text !== 'string') return text; let c = text; for (const p of SENSITIVE_PATTERNS) c = c.replace(p, '[REDACTED]'); return c; }\nfunction validateNonEmptyString(value, fieldName) { if (!value || typeof value !== 'string') return { valid: false, error: \`The "\${fieldName}" parameter is required and must be a non-empty string.\` }; const t = value.trim(); if (!t.length) return { valid: false, error: \`The "\${fieldName}" parameter must not be empty.\` }; return { valid: true, value: t }; }\n\nexport function validate(params) {\n  const { action } = params || {};\n  if (!action || !VALID_ACTIONS.includes(action)) return { valid: false, error: \`Invalid action "\${action}". Must be one of: \${VALID_ACTIONS.join(', ')}\` };\n  switch (action) {\n${validationCases}\n    default: return { valid: false, error: \`Unknown action "\${action}".\` };\n  }\n}\n\n${handlers}\n\nexport async function execute(params, context) {\n  const { action } = params || {};\n  if (!action || !VALID_ACTIONS.includes(action)) return { result: \`Error: Invalid action "\${action}". Must be one of: \${VALID_ACTIONS.join(', ')}\`, metadata: { success: false, action: action || null, error: 'INVALID_ACTION', timestamp: new Date().toISOString() } };\n  try {\n    switch (action) {\n${switchCases}\n      default: return { result: \`Error: Unknown action.\`, metadata: { success: false, action, error: 'INVALID_ACTION', timestamp: new Date().toISOString() } };\n    }\n  } catch (error) { return { result: redactSensitive(\`Error: \${error.message}\`), metadata: { success: false, action, error: 'UPSTREAM_ERROR', timestamp: new Date().toISOString() } }; }\n}\n\nexport const meta = { name: '${s.slug}', version: '1.0.0', description: '${s.description}', actions: VALID_ACTIONS };\nexport { getClient, providerNotConfiguredError, resolveTimeout, requestWithTimeout, redactSensitive, validateNonEmptyString, VALID_ACTIONS, DEFAULT_TIMEOUT_MS, MAX_TIMEOUT_MS };\n`;
}

function genSkillJson(s) {
  return JSON.stringify({ name:s.slug, version:'1.0.0', displayName:s.displayName, description:s.description, category:s.category, icon:s.icon, author:'claw2agent', layer:'L1', requiresApiKey:true, apiKeyLabel:`${s.displayName} API Key`, tags:s.tags, verified:true, tier:'pro', implemented:true, config:{ provider:'providerClient', timeoutMs:30000, maxTimeoutMs:120000 }, toolDefinition:{ name:s.slug.replace(/-/g,'_'), description:s.description, parameters:{ type:'object', properties:{ action:{ type:'string', enum:s.actions.map(a=>a.name) } }, required:['action'] } } }, null, 2) + '\n';
}

function genTest(s) {
  const sampleLines = s.actions.map(a => `const sample_${a.name} = ${JSON.stringify(a.response)};`).join('\n');
  const provTests = s.actions.map(a => { const ps = a.params.filter(p=>p.req).map(p=>`${p.n}:'test'`).join(','); return `  it('fail ${a.name} no client', async()=>{ const r=await execute({action:'${a.name}'${ps?','+ps:''}},{}); assert.equal(r.metadata.success,false); assert.equal(r.metadata.error.code,'PROVIDER_NOT_CONFIGURED'); });`; }).join('\n');
  const actionTests = s.actions.map(a => { const rp=a.params.filter(p=>p.req); const ps=rp.map(p=>`${p.n}:'test'`).join(','); let tests = [`  it('${a.name} success', async()=>{ const r=await execute({action:'${a.name}'${ps?','+ps:''}},mockContext(sample_${a.name})); assert.equal(r.metadata.success,true); assert.equal(r.metadata.action,'${a.name}'); });`]; if(rp.length) { tests.push(`  it('${a.name} missing param', async()=>{ const r=await execute({action:'${a.name}'},mockContext(sample_${a.name})); assert.equal(r.metadata.success,false); assert.equal(r.metadata.error,'INVALID_INPUT'); });`); tests.push(`  it('${a.name} non-string param', async()=>{ const r=await execute({action:'${a.name}',${rp[0].n}:123},mockContext(sample_${a.name})); assert.equal(r.metadata.success,false); });`); } return `describe('${s.slug}: ${a.name}', ()=>{ beforeEach(()=>{});\n${tests.join('\n')}\n});`; }).join('\n\n');
  const toTests = s.actions.map(a => { const ps=a.params.filter(p=>p.req).map(p=>`${p.n}:'test'`).join(','); return `  it('timeout ${a.name}', async()=>{ const r=await execute({action:'${a.name}'${ps?','+ps:''}},mockContextTimeout()); assert.equal(r.metadata.success,false); assert.equal(r.metadata.error,'TIMEOUT'); });`; }).join('\n');
  const pathTests = s.actions.map(a => { const ps=a.params.filter(p=>p.req).map(p=>`${p.n}:'test'`).join(','); return `  it('path ${a.name}', async()=>{ let p=null; const ctx={providerClient:{request:async(m,pa)=>{p=pa;return sample_${a.name};}},config:{timeoutMs:5000}}; await execute({action:'${a.name}'${ps?','+ps:''}},ctx); assert.ok(p!==null); });`; }).join('\n');
  const valTests = s.actions.map(a => { const rp=a.params.filter(p=>p.req); if(!rp.length) return `  it('${a.name} valid no params', ()=>{ assert.equal(validate({action:'${a.name}'}).valid,true); });`; const ps=rp.map(p=>`${p.n}:'t'`).join(','); return `  it('${a.name} req params', ()=>{ assert.equal(validate({action:'${a.name}'}).valid,false); assert.equal(validate({action:'${a.name}',${ps}}).valid,true); });`; }).join('\n');
  const fp = s.actions[0]; const fps = fp.params.filter(p=>p.req).map(p=>`${p.n}:'test'`).join(',');
  return `import assert from 'node:assert/strict';\nimport { describe, it, beforeEach } from 'node:test';\nimport { execute, validate, meta, getClient, providerNotConfiguredError, resolveTimeout, requestWithTimeout, redactSensitive, validateNonEmptyString, VALID_ACTIONS, DEFAULT_TIMEOUT_MS, MAX_TIMEOUT_MS } from '../handler.js';\n\nfunction mockContext(r,c){ return {providerClient:{request:async()=>r},config:c||{timeoutMs:5000}}; }\nfunction mockContextError(e){ return {providerClient:{request:async()=>{throw e;}},config:{timeoutMs:1000}}; }\nfunction mockContextTimeout(){ return {providerClient:{request:async()=>{const e=new Error('aborted');e.name='AbortError';throw e;}},config:{timeoutMs:100}}; }\n\n${sampleLines}\n\ndescribe('${s.slug}: action validation', ()=>{ beforeEach(()=>{});\n  it('reject invalid', async()=>{ const r=await execute({action:'invalid'},{}); assert.equal(r.metadata.success,false); assert.equal(r.metadata.error,'INVALID_ACTION'); });\n  it('reject missing', async()=>{ const r=await execute({},{}); assert.equal(r.metadata.success,false); });\n  it('reject null', async()=>{ const r=await execute(null,{}); assert.equal(r.metadata.success,false); });\n  it('reject undefined', async()=>{ const r=await execute(undefined,{}); assert.equal(r.metadata.success,false); });\n  it('list actions in error', async()=>{ const r=await execute({action:'bad'},{}); for(const a of VALID_ACTIONS) assert.ok(r.result.includes(a)); });\n});\n\ndescribe('${s.slug}: PROVIDER_NOT_CONFIGURED', ()=>{ beforeEach(()=>{});\n${provTests}\n});\n\n${actionTests}\n\ndescribe('${s.slug}: timeout', ()=>{ beforeEach(()=>{});\n${toTests}\n});\n\ndescribe('${s.slug}: network errors', ()=>{ beforeEach(()=>{});\n  it('UPSTREAM_ERROR', async()=>{ const r=await execute({action:'${fp.name}'${fps?','+fps:''}},mockContextError(new Error('fail'))); assert.equal(r.metadata.success,false); assert.equal(r.metadata.error,'UPSTREAM_ERROR'); });\n  it('include msg', async()=>{ const r=await execute({action:'${fp.name}'${fps?','+fps:''}},mockContextError(new Error('fail'))); assert.ok(r.result.includes('fail')); });\n});\n\ndescribe('${s.slug}: getClient', ()=>{ beforeEach(()=>{});\n  it('prefer provider', ()=>{ assert.equal(getClient({providerClient:{request:()=>{}},gatewayClient:{request:()=>{}}}).type,'provider'); });\n  it('fallback gateway', ()=>{ assert.equal(getClient({gatewayClient:{request:()=>{}}}).type,'gateway'); });\n  it('null empty', ()=>{ assert.equal(getClient({}),null); });\n  it('null undef', ()=>{ assert.equal(getClient(undefined),null); });\n  it('null null', ()=>{ assert.equal(getClient(null),null); });\n});\n\ndescribe('${s.slug}: redactSensitive', ()=>{ beforeEach(()=>{});\n  it('redact api_key', ()=>{ assert.ok(redactSensitive('api_key: sample_key_placeholder').includes('[REDACTED]')); });\n  it('redact bearer', ()=>{ assert.ok(redactSensitive('bearer: test_placeholder_token').includes('[REDACTED]')); });\n  it('clean unchanged', ()=>{ assert.equal(redactSensitive('clean'),'clean'); });\n  it('non-string', ()=>{ assert.equal(redactSensitive(42),42); });\n});\n\ndescribe('${s.slug}: resolveTimeout', ()=>{ beforeEach(()=>{});\n  it('default', ()=>{ assert.equal(resolveTimeout({}),DEFAULT_TIMEOUT_MS); });\n  it('undef', ()=>{ assert.equal(resolveTimeout(undefined),DEFAULT_TIMEOUT_MS); });\n  it('custom', ()=>{ assert.equal(resolveTimeout({config:{timeoutMs:60000}}),60000); });\n  it('cap', ()=>{ assert.equal(resolveTimeout({config:{timeoutMs:999999}}),MAX_TIMEOUT_MS); });\n  it('ignore 0', ()=>{ assert.equal(resolveTimeout({config:{timeoutMs:0}}),DEFAULT_TIMEOUT_MS); });\n  it('ignore neg', ()=>{ assert.equal(resolveTimeout({config:{timeoutMs:-1}}),DEFAULT_TIMEOUT_MS); });\n  it('ignore str', ()=>{ assert.equal(resolveTimeout({config:{timeoutMs:'x'}}),DEFAULT_TIMEOUT_MS); });\n  it('D=30000', ()=>{ assert.equal(DEFAULT_TIMEOUT_MS,30000); });\n  it('M=120000', ()=>{ assert.equal(MAX_TIMEOUT_MS,120000); });\n});\n\ndescribe('${s.slug}: validate()', ()=>{ beforeEach(()=>{});\n  it('reject invalid', ()=>{ assert.equal(validate({action:'bad'}).valid,false); });\n  it('reject null', ()=>{ assert.equal(validate(null).valid,false); });\n${valTests}\n});\n\ndescribe('${s.slug}: meta', ()=>{ beforeEach(()=>{});\n  it('name', ()=>{ assert.equal(meta.name,'${s.slug}'); });\n  it('version', ()=>{ assert.equal(meta.version,'1.0.0'); });\n  it('actions count', ()=>{ assert.equal(meta.actions.length,${s.actions.length}); });\n});\n\ndescribe('${s.slug}: gateway fallback', ()=>{ beforeEach(()=>{});\n  it('use gateway', async()=>{ const ctx={gatewayClient:{request:async()=>sample_${fp.name}},config:{timeoutMs:5000}}; const r=await execute({action:'${fp.name}'${fps?','+fps:''}},ctx); assert.equal(r.metadata.success,true); });\n});\n\ndescribe('${s.slug}: providerNotConfiguredError', ()=>{ beforeEach(()=>{});\n  it('success false', ()=>{ assert.equal(providerNotConfiguredError().metadata.success,false); });\n  it('code', ()=>{ assert.equal(providerNotConfiguredError().metadata.error.code,'PROVIDER_NOT_CONFIGURED'); });\n  it('retriable false', ()=>{ assert.equal(providerNotConfiguredError().metadata.error.retriable,false); });\n});\n\ndescribe('${s.slug}: constants', ()=>{ beforeEach(()=>{});\n  it('VALID_ACTIONS', ()=>{ assert.deepEqual(VALID_ACTIONS,[${s.actions.map(a=>`'${a.name}'`).join(',')}]); });\n});\n\ndescribe('${s.slug}: request paths', ()=>{ beforeEach(()=>{});\n${pathTests}\n});\n`;
}

function genReadme(s) {
  const acts = s.actions.map(a => { const rows = a.params.map(p => `| ${p.n} | ${p.req?'✅':'❌'} | ${p.t} |`).join('\n'); return `### \`${a.name}\`\n${a.params.length ? `| Param | Req | Type |\n|-------|-----|------|\n${rows}` : '_No required parameters._'}`; }).join('\n\n');
  return `# ${s.displayName} [L1]\n\n${s.description}\n\n## Actions\n\n${acts}\n\n## Error Codes\n\n| Code | Retriable |\n|------|-----------|\n| INVALID_ACTION | No |\n| INVALID_INPUT | No |\n| PROVIDER_NOT_CONFIGURED | No |\n| TIMEOUT | Yes |\n| UPSTREAM_ERROR | Maybe |\n\n## Testing\n\n\`\`\`bash\nnode --test skills/${s.slug}/__tests__/handler.test.js\n\`\`\`\n`;
}

for (const spec of SKILLS) {
  const base = `skills/${spec.slug}`;
  mkdirSync(`${base}/__tests__`, { recursive: true });
  if (!['home-assistant-api','plex-api','transmission-rpc','calibre-api','frigate-nvr-api','video-editor-ffmpeg','color-palette-extractor','music-generator'].some(s => { try { return require(`../${base}/package.json`); } catch { return false; } })) {
    try { writeFileSync(`${base}/package.json`, '{ "type": "module" }\n', { flag: 'wx' }); } catch {}
  }
  writeFileSync(`${base}/handler.js`, genHandler(spec));
  writeFileSync(`${base}/skill.json`, genSkillJson(spec));
  writeFileSync(`${base}/__tests__/handler.test.js`, genTest(spec));
  writeFileSync(`${base}/README.md`, genReadme(spec));
  console.log(`✅ ${spec.slug} (${spec.actions.length} actions)`);
}
console.log(`\nBatch 5: ${SKILLS.length} skills generated.`);
